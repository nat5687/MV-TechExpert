"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/tsup@6.7.0_typescript@5.0.4/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@6.7.0_typescript@5.0.4/node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// ../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/cleanStackTrace.js
var require_cleanStackTrace = __commonJS({
  "../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/cleanStackTrace.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cleanStackTrace = void 0;
    function cleanStackTrace(err, numberOfStackTraceLinesToRemove) {
      err.stack = clean(err.stack, numberOfStackTraceLinesToRemove);
    }
    exports.cleanStackTrace = cleanStackTrace;
    function clean(errStack, numberOfStackTraceLinesToRemove) {
      if (!errStack) {
        return errStack;
      }
      const stackLines = splitByLine(errStack);
      let linesRemoved = 0;
      const stackLine__cleaned = stackLines.filter((line) => {
        if (line.includes(" (internal/") || line.includes(" (node:internal")) {
          return false;
        }
        if (linesRemoved < numberOfStackTraceLinesToRemove && isStackTraceLine(line)) {
          linesRemoved++;
          return false;
        }
        return true;
      }).join("\n");
      return stackLine__cleaned;
    }
    function isStackTraceLine(line) {
      return line.startsWith("    at ");
    }
    function splitByLine(str) {
      return str.split(/\r?\n/);
    }
  }
});

// ../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/newError.js
var require_newError = __commonJS({
  "../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/newError.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newError = void 0;
    var cleanStackTrace_1 = require_cleanStackTrace();
    function newError2(errorMessage, numberOfStackTraceLinesToRemove) {
      let err;
      {
        var stackTraceLimit__original = Error.stackTraceLimit;
        Error.stackTraceLimit = Infinity;
        err = new Error(errorMessage);
        Error.stackTraceLimit = stackTraceLimit__original;
      }
      (0, cleanStackTrace_1.cleanStackTrace)(err, numberOfStackTraceLinesToRemove);
      return err;
    }
    exports.newError = newError2;
  }
});

// ../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/@brillout+libassert@0.5.8/node_modules/@brillout/libassert/dist/cjs/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newError = void 0;
    var newError_1 = require_newError();
    Object.defineProperty(exports, "newError", { enumerable: true, get: function() {
      return newError_1.newError;
    } });
  }
});

// vite-plugin-ssr.ts
var vite_plugin_ssr_exports = {};
__export(vite_plugin_ssr_exports, {
  assert: () => assert,
  default: () => allPlugins,
  getOutDir: () => getOutDir,
  getOutput: () => getOutput,
  getRoot: () => getRoot,
  getSsrEndpoint: () => getSsrEndpoint,
  prerender: () => prerender,
  vitePluginSsrVercelPlugin: () => vitePluginSsrVercelPlugin,
  vitePluginVercelVpsCopyStaticAssetsPlugins: () => vitePluginVercelVpsCopyStaticAssetsPlugins,
  vitePluginVercelVpsIsrPlugin: () => vitePluginVercelVpsIsrPlugin
});
module.exports = __toCommonJS(vite_plugin_ssr_exports);
init_cjs_shims();
var import_prerender = require("vite-plugin-ssr/prerender");
var import_promises = __toESM(require("fs/promises"), 1);
var import_path = __toESM(require("path"), 1);
var import_vite = require("vite");
var import_setup = require("vite-plugin-ssr/__internal/setup");
var import_internal = require("vite-plugin-ssr/__internal");

// ../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/index.js
init_cjs_shims();
var import_crypto = require("crypto");

// ../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/url-alphabet/index.js
init_cjs_shims();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = (bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    (0, import_crypto.randomFillSync)(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    (0, import_crypto.randomFillSync)(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
};
var nanoid = (size = 21) => {
  fillPool(size -= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
};

// route-regex.ts
init_cjs_shims();
function getSegmentRegex(segment) {
  if (segment.startsWith("@")) {
    return "/[^/]+";
  } else if (segment === "*") {
    return "/.+?";
  }
  return `/` + segment;
}
function getParametrizedRoute(route2) {
  const segments = (route2.replace(/\/$/, "") || "/").slice(1).split("/");
  return segments.map(getSegmentRegex).join("");
}

// vite-plugin-ssr.ts
var import_libassert = __toESM(require_cjs(), 1);
var libName = "vite-plugin-ssr:vercel";
var rendererDestination = "ssr_";
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = (0, import_libassert.newError)(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}
function getRoot(config) {
  return (0, import_vite.normalizePath)(config.root || process.cwd());
}
function getOutDirRoot(config) {
  const outDir = config.build.outDir;
  return outDir.endsWith("/server") || outDir.endsWith("/client") ? import_path.default.normalize(import_path.default.join(outDir, "..")) : outDir;
}
function getOutput(config, suffix) {
  var _a, _b;
  return import_path.default.join(
    ((_a = config.vercel) == null ? void 0 : _a.outDir) ? "" : getRoot(config),
    ((_b = config.vercel) == null ? void 0 : _b.outDir) ?? ".vercel/output",
    suffix ?? ""
  );
}
function getOutDir(config, force) {
  const p = import_path.default.join(config.root, (0, import_vite.normalizePath)(config.build.outDir));
  if (!force)
    return p;
  return import_path.default.join(import_path.default.dirname(p), force);
}
async function copyDir(src, dest) {
  await import_promises.default.mkdir(dest, { recursive: true });
  const entries = await import_promises.default.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = import_path.default.join(src, entry.name);
    const destPath = import_path.default.join(dest, entry.name);
    if (entry.isDirectory()) {
      await copyDir(srcPath, destPath);
    } else {
      await import_promises.default.copyFile(srcPath, destPath);
    }
  }
}
function assertIsr(resolvedConfig, exports) {
  var _a, _b, _c;
  if (exports === null || typeof exports !== "object")
    return null;
  if (!("isr" in exports))
    return null;
  const isr = exports.isr;
  assert(
    typeof isr === "boolean" || typeof isr === "object" && typeof isr.expiration === "number" && isr.expiration > 0,
    ` \`{ expiration }\` must be a positive number`
  );
  if (isr === true) {
    assert(
      typeof ((_a = resolvedConfig.vercel) == null ? void 0 : _a.expiration) === "number" && ((_b = resolvedConfig.vercel) == null ? void 0 : _b.expiration) > 0,
      "`export const isr = true;` requires a default positive value for `expiration` in vite config"
    );
    return (_c = resolvedConfig.vercel) == null ? void 0 : _c.expiration;
  }
  return isr.expiration;
}
var prerender = async (resolvedConfig) => {
  const routes = {};
  await (0, import_prerender.prerender)({
    viteConfig: {
      root: getRoot(resolvedConfig),
      build: {
        outDir: getOutDirRoot(resolvedConfig)
      }
    },
    async onPagePrerender(pageContext) {
      var _a;
      const { filePath, fileContent } = pageContext._prerenderResult;
      const isr = assertIsr(resolvedConfig, pageContext.exports);
      delete pageContext.urlPathname;
      delete pageContext.urlParsed;
      const foundRoute = await (0, import_internal.route)(pageContext);
      if (!pageContext.is404) {
        assert(foundRoute, `Page with id ${pageContext._pageId} not found`);
        const routeMatch = (_a = foundRoute.pageContextAddendum._routeMatches) == null ? void 0 : _a[0];
        if (typeof isr === "number" && routeMatch && typeof routeMatch !== "string" && routeMatch.routeType === "FILESYSTEM") {
          return;
        }
      }
      const relPath = import_path.default.relative(
        getOutDir(resolvedConfig, "client"),
        filePath
      );
      const newFilePath = import_path.default.join(
        getOutput(resolvedConfig, "static"),
        relPath
      );
      const parsed = import_path.default.parse(relPath);
      const pathJoined = parsed.name === "index" ? parsed.dir : import_path.default.join(parsed.dir, parsed.name);
      if (relPath.endsWith(".html")) {
        routes[relPath] = {
          path: pathJoined === "index" ? "" : pathJoined
        };
      }
      await import_promises.default.mkdir(import_path.default.dirname(newFilePath), { recursive: true });
      await import_promises.default.writeFile(newFilePath, fileContent);
    }
  });
  return routes;
};
function getRouteDynamicRoute(pageRoutes, pageId) {
  for (const route2 of pageRoutes) {
    if (route2.pageId === pageId) {
      if (route2.routeType === "STRING") {
        return getParametrizedRoute(route2.routeString);
      } else if (route2.routeType === "FUNCTION") {
        return () => {
        };
      }
    }
  }
  return null;
}
function getRouteFsRoute(pageRoutes, pageId) {
  for (const route2 of pageRoutes) {
    if (route2.pageId === pageId && route2.routeType === "FILESYSTEM") {
      return route2.routeString;
    }
  }
  return null;
}
async function getSsrEndpoint(userConfig, source) {
  const sourcefile = source ?? import_path.default.join(__dirname, "..", "templates", "ssr_.template.ts");
  const contents = await import_promises.default.readFile(sourcefile, "utf-8");
  const resolveDir = import_path.default.dirname(sourcefile);
  return {
    source: {
      contents,
      sourcefile,
      loader: sourcefile.endsWith(".ts") ? "ts" : sourcefile.endsWith(".tsx") ? "tsx" : sourcefile.endsWith(".js") ? "js" : sourcefile.endsWith(".jsx") ? "jsx" : "default",
      resolveDir
    },
    destination: rendererDestination,
    addRoute: false
  };
}
function vitePluginSsrVercelPlugin(options = {}) {
  return {
    name: libName,
    apply: "build",
    async config(userConfig) {
      var _a, _b, _c, _d, _e;
      if (!((_a = userConfig.build) == null ? void 0 : _a.ssr))
        return {};
      const additionalEndpoints = ((_c = (_b = userConfig.vercel) == null ? void 0 : _b.additionalEndpoints) == null ? void 0 : _c.flatMap((e) => e.destination).some((d) => d === rendererDestination)) ? (_d = userConfig.vercel) == null ? void 0 : _d.additionalEndpoints : [await getSsrEndpoint(userConfig)];
      return {
        vitePluginSsr: {
          prerender: {
            disableAutoRun: true
          }
        },
        vercel: {
          prerender: ((_e = userConfig.vercel) == null ? void 0 : _e.prerender) ?? prerender,
          additionalEndpoints,
          rewrites: [
            {
              source: options.source ? `(${options.source})` : "((?!/api).*)",
              destination: `/${rendererDestination}/?__original_path=$1`,
              enforce: "post"
            }
          ]
        }
      };
    }
  };
}
function findPageFile(pageId, pageFilesAll) {
  return pageFilesAll.find(
    (p) => p.pageId === pageId && p.fileType === ".page"
  );
}
function vitePluginVercelVpsIsrPlugin() {
  return {
    name: "vite-plugin-vercel:vps-isr",
    apply: "build",
    async config(userConfig) {
      return {
        vercel: {
          isr: async () => {
            var _a;
            let userIsr = {};
            if ((_a = userConfig.vercel) == null ? void 0 : _a.isr) {
              if (typeof userConfig.vercel.isr === "function") {
                userIsr = await userConfig.vercel.isr();
              } else {
                userIsr = userConfig.vercel.isr;
              }
            }
            const { pageFilesAll, allPageIds, pageRoutes } = await (0, import_internal.getPagesAndRoutes)();
            await Promise.all(pageFilesAll.map((p) => {
              var _a2;
              return (_a2 = p.loadFile) == null ? void 0 : _a2.call(p);
            }));
            const pagesWithIsr = await Promise.all(
              allPageIds.map(async (pageId) => {
                const page = await findPageFile(pageId, pageFilesAll);
                assert(
                  page,
                  `Cannot find page ${pageId}. Contact the vite-plugin-vercel maintainer on GitHub / Discord`
                );
                const route2 = getRouteDynamicRoute(pageRoutes, pageId) ?? getRouteFsRoute(pageRoutes, pageId);
                let isr = assertIsr(userConfig, page.fileExports);
                if (typeof route2 === "function" && isr) {
                  console.warn(
                    `Page ${pageId}: ISR is not supported when using route function. Remove \`{ isr }\` export or use a route string if possible.`
                  );
                  isr = null;
                }
                return {
                  _pageId: pageId,
                  // used for debug purpose
                  filePath: page.filePath,
                  isr,
                  route: typeof route2 === "string" ? getParametrizedRoute(route2) : null
                };
              })
            );
            return pagesWithIsr.filter((p) => typeof p.isr === "number").reduce((acc, cur) => {
              const path2 = cur._pageId.replace(/\/index$/g, "") + "-" + nanoid();
              acc[path2] = {
                expiration: cur.isr,
                symlink: rendererDestination,
                route: cur.route ? cur.route + "(?:\\/index\\.pageContext\\.json)?" : void 0
              };
              return acc;
            }, userIsr);
          }
        }
      };
    }
  };
}
function vitePluginVercelVpsCopyStaticAssetsPlugins() {
  let resolvedConfig;
  return {
    apply: "build",
    name: "vite-plugin-vercel:vps-copy-static-assets",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
    },
    async closeBundle() {
      var _a;
      if (!((_a = resolvedConfig.build) == null ? void 0 : _a.ssr))
        return;
      await copyDistClientToOutputStatic(resolvedConfig);
    }
  };
}
async function copyDistClientToOutputStatic(resolvedConfig) {
  await copyDir(
    getOutDir(resolvedConfig, "client"),
    getOutput(resolvedConfig, "static")
  );
}
function allPlugins(options = {}) {
  return [
    vitePluginVercelVpsIsrPlugin(),
    vitePluginSsrVercelPlugin(options),
    vitePluginVercelVpsCopyStaticAssetsPlugins()
  ];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assert,
  getOutDir,
  getOutput,
  getRoot,
  getSsrEndpoint,
  prerender,
  vitePluginSsrVercelPlugin,
  vitePluginVercelVpsCopyStaticAssetsPlugins,
  vitePluginVercelVpsIsrPlugin
});
